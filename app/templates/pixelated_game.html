<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="google-adsense-account" content="ca-pub-4299478664367910">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Make the title more descriptive -->
    <title>Emojile - Daily Emoji Guessing Game</title>
    <!-- Add a meta description -->
    <meta name="description" content="Guess the name of the daily emoji! A fun, free word puzzle game similar to Wordle, but with emojis. Test your emoji knowledge.">
    <!-- Add the favicon link here -->
    <link rel="icon" href="{{ url_for('static', filename='emojiriddlewebicon.png') }}" type="image/png">
    <!-- Existing CSS links -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Define color variables */
        :root {
            --bg-color: #ffffff;
            --text-color: #212529;
            --card-bg: #ffffff;
            --card-border: #dee2e6;
            --tile-bg: #f8f9fa;
            --tile-border: #ced4da;
            --tile-text: #495057;
            --tile-disabled-bg: #e9ecef;
            --tile-disabled-text: #6c757d;
            --tile-correct-bg: #90ee90; /* Light green */
            --tile-correct-border: #5cb85c;
            --tile-correct-text: #333;
            --muted-text: #6c757d;
            --link-color: #0d6efd;
            --alert-info-bg: #cfe2ff;
            --alert-info-text: #084298;
            /* Add other alert colors if needed */
        }

        body.dark-mode {
            --bg-color: #212529;
            --text-color: #f8f9fa;
            --card-bg: #343a40;
            --card-border: #495057;
            --tile-bg: #495057;
            --tile-border: #6c757d;
            --tile-text: #f8f9fa;
            --tile-disabled-bg: #343a40;
            --tile-disabled-text: #6c757d;
            --tile-correct-bg: #2e6a2e; /* Darker green */
            --tile-correct-border: #3a8a3a;
            --tile-correct-text: #e9ecef;
            --muted-text: #adb5bd;
            --link-color: #6ea8fe;
            --alert-info-bg: #031633;
            --alert-info-text: #6ea8fe;
            /* Add other alert colors if needed */
        }

        /* Apply variables */
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s; /* Smooth transition */
        }

        .card {
            background-color: var(--card-bg);
            border-color: var(--card-border);
        }

        .card-body {
             color: var(--text-color); /* Ensure text inside card uses theme color */
        }

        .answer-tile {
            border-bottom: 3px solid var(--tile-border); /* Use theme variable */
            width: 35px; /* Or your preferred width */
            height: 45px; /* Or your preferred height */
            display: inline-flex;
            justify-content: center;
            align-items: flex-end; 
            font-size: 1.8rem; /* Adjust if necessary */
            font-weight: bold;
            text-transform: uppercase;
            padding-bottom: 2px; /* Ensures letter is just above the border */
            /* line-height: 1; */ /* REMOVE THIS LINE or comment it out */
            box-sizing: border-box; /* Ensures padding and border are included in width/height */
        }
        .answer-tile.space {
             border-bottom: none;
        }

        /* NEW: Explicit style for revealed letters to ensure they look different */
        .answer-tile.revealed {
            /* No specific border change needed here if you always want the bottom border for letters too */
            /* If you wanted to REMOVE the border for revealed letters, you'd add: */
            /* border-bottom: none; */
        }

        .letter-tile {
            background-color: var(--tile-bg);
            border: 1px solid var(--tile-border);
            color: var(--tile-text);
            /* ... other letter-tile styles ... */
        }

        .letter-tile.disabled {
            background-color: var(--tile-disabled-bg);
            color: var(--tile-disabled-text);
            cursor: default;
            opacity: 0.7;
        }

         .letter-tile.correct {
            background-color: var(--tile-correct-bg);
            border-color: var(--tile-correct-border);
            color: var(--tile-correct-text);
        }

        .guesses-left, .category-display, .text-muted {
            color: var(--muted-text) !important; /* Use important if Bootstrap overrides */
        }

        a {
            color: var(--link-color);
        }

        /* Update alert styles if needed */
        .alert-info { /* Example for info */
             color: var(--alert-info-text);
             background-color: var(--alert-info-bg);
             border-color: var(--alert-info-bg); /* Adjust border as needed */
        }
        /* Add rules for .alert-success, .alert-danger etc. if you use them */


        /* Style for the toggle button */
        #darkModeToggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1050; /* Ensure it's above most elements */
        }

        /* ... rest of your existing styles ... */
        .emoji-display { 
            font-size: 5rem; 
            text-align: center; 
            margin-bottom: 10px; 
            /* Add this line to prevent selection */
            user-select: none; /* Standard */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE/Edge */
        }
        .category-display { text-align: center; color: #6c757d; margin-bottom: 20px; font-style: italic;}
        .container { max-width: 600px; margin-top: 50px; }
        .answer-tiles {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-bottom: 30px;
            min-height: 50px;
            flex-wrap: wrap; /* Allow wrapping for longer answers */
        }
        .answer-tile {
            border-bottom: 3px solid #ccc;
            width: 35px;
            height: 45px;
            display: inline-flex;
            justify-content: center;
            align-items: flex-end; /* Align letter to bottom */
            font-size: 1.8rem;
            font-weight: bold;
            text-transform: uppercase;
            padding-bottom: 2px;
        }
        .answer-tile.space {
            border-bottom: none; /* No line for spaces */
        }
        .alphabet-tiles {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .letter-tile {
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 40px;
            height: 40px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            text-decoration: none;
            color: #333;
            background-color: #f8f9fa;
            transition: background-color 0.2s;
        }
        .letter-tile:hover {
            background-color: #e2e6ea;
        }
        .letter-tile.disabled {
            background-color: #d3d3d3;
            color: #888;
            pointer-events: none; /* Make it unclickable */
            border-color: #bbb;
        }
        /* Add style for correctly guessed letters */
        .letter-tile.correct {
            background-color: #90ee90; /* Light green */
            border-color: #5cb85c;
            color: #333; /* Ensure text is still readable */
        }
        .guesses-left {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.1rem;
            color: #6c757d;
        }
    </style>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1LVW18WYHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1LVW18WYHP');
</script>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar">
        <a href="{{ url_for('main.index', mode='Classic') }}" class="sidebar-item"><span>üè†</span> <span class="sidebar-text">Home</span></a>

        <!-- Classic Game Link (Top Level) -->
        <a href="{{ url_for('main.index', mode='Classic') }}" class="sidebar-item"><span>üß©</span> <span class="sidebar-text">Classic</span></a>

        <!-- Link to More Games Page -->
        <a href="{{ url_for('main.more_games') }}" class="sidebar-item"> <!-- Changed href, removed collapsible div wrapper -->
            <span>üéÆ</span>
            <span class="sidebar-text">More Games</span>
            <!-- Removed dropdown arrow span -->
        </a>
        <!-- Removed the entire div#emojiGamesSubmenu block -->

        <!--<a href="#" class="sidebar-item"><span>‚öôÔ∏è</span> <span class="sidebar-text">Settings</span></a>-->
    </div>

    <!-- Main Content Wrapper -->
    <div class="main-content">
        <!-- Dark Mode Toggle Button (Moved inside main-content if needed, or keep fixed) -->
        <button id="darkModeToggle" class="btn btn-secondary btn-sm">üåô</button>

        <div class="container">
            <!-- Ensure this is the primary heading -->
            <h1 class="text-center mb-4">Guess the Mystery Pixelated Emoji of the Day!</h1>

            <!-- Countdown Timer Display -->
            <div id="countdownTimer" class="text-center text-muted mb-3" style="font-size: 0.9rem;">
                Next Pixelated Emojile in: <span id="timerDisplay">--:--:--</span>
            </div>

            <div class="text-center my-4">
                <h2 id="category-display" class="text-muted">{{ category }}</h2>

                <!-- REMOVE THIS OLD DISPLAY (if still present) -->
                <!--
                {% if emoji_char %}
                <div class="emoji-display" style="font-size: 5rem; margin-bottom: 20px;">
                    {{ emoji_char }}
                </div>
                {% endif %}
                -->

                <!-- Emoji Display Area for Pixelated Mode -->
                <div id="emoji-container" class="my-3">
                    <!-- The span element should NOT be here -->
                    <canvas id="pixelated-emoji-canvas"></canvas>
                </div>
            </div>

            {% with messages = get_flashed_messages(with_categories=true) %}
                {% if messages %}
                    {% for category, message in messages %}
                        <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                            {{ message }}
                            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                        </div>
                    {% endfor %}
                {% endif %}
            {% endwith %}

            {% if current_riddle_id is not none %} {# Check if we have a riddle ID #}
                <div class="card">
                    <div class="card-body">
                        <!-- Display Category -->
                        <div class="category-display">
                            Category: {{ category }}
                        </div>

                        <!-- Guesses Left Display -->
                        <div class="guesses-left" id="guesses-left-display">
                            Guesses left: {{ max_guesses - incorrect_guesses }}
                        </div>
                        <!-- End Guesses Left Display -->

                        <!-- Answer Display (Uses emoji name passed as answer_display) -->
                        <div class="answer-tiles">
                            {% for char_in_display in answer_display %}
                                {% if char_in_display == ' ' %}
                                    <span class="answer-tile space" id="answer-char-{{ loop.index0 }}">&nbsp;</span>
                                {% elif char_in_display == '_' %}
                                    <span class="answer-tile" id="answer-char-{{ loop.index0 }}">&nbsp;</span>
                                {% else %} {# This is a revealed letter or a non-alpha char from original answer like '-' #}
                                    <span class="answer-tile" id="answer-char-{{ loop.index0 }}">{{ char_in_display.upper() }}</span>
                                {% endif %}
                            {% endfor %}
                        </div>
                        <!-- End Answer Display -->

                        <!-- Alphabet Tiles -->
                        <div class="alphabet-tiles text-center mt-4">
                            {% for letter in alphabet %}
                                {% set letter_lower = letter.lower() %}
                                {% set is_guessed = letter_lower in guessed_letters %}
                                {% set is_correct = is_guessed and letter_lower in answer_display %}
                                {% set is_disabled = is_guessed or game_over %}
                                {# Change from <a> to <button> #}
                                <button type="button"
                                        class="letter-tile btn btn-outline-secondary m-1
                                           {% if is_disabled %}disabled{% endif %}
                                           {% if is_correct %}correct{% endif %}"
                                        data-letter="{{ letter_lower }}" {# Store letter in data attribute #}
                                        {% if is_disabled %}disabled aria-disabled="true"{% endif %}>
                                    {{ letter }}
                                </button>
                            {% endfor %}
                        </div>
                        <!-- End Alphabet Tiles -->

                        <!-- Share Button (Conditionally Hidden) -->
                        <div class="text-center mt-3" id="share-section" {% if not game_over %}style="display: none;"{% endif %}> {# Show if game_over is true #}
                            <button id="shareButton" class="btn btn-success">Share Score</button>
                            <span id="copy-feedback" class="ms-2" style="display: none; color: green;">Copied!</span>
                        </div>
                        <!-- End Share Button -->

                    </div> {# End card-body #}
                </div> {# End card #}
            {% else %}
                <div class="alert alert-warning" role="alert">
                    No riddle available today, or database is empty. Please check back tomorrow or run 'flask init-db'.
                </div>
            {% endif %}

            <!-- Stats Display -->
            <div class="card mt-4" id="stats-card" {% if stats.total_games == 0 %}style="display: none;"{% endif %}> {# ID for showing/hiding #}
                <div class="card-header">
                    <!-- Use a heading for structure within the card -->
                    <h2>Your Statistics (Pixelated mode) </h2>
                    {% if streak_test_mode %}
                        <span class="badge bg-warning text-dark float-end">Streak Test Mode Active</span>
                    {% endif %}
                </div>
                <div class="card-body" id="stats-body"> {# ID for updating content #}
                    <div class="row">
                        <div class="col-md-6">
                            <p><strong>Total Games Played:</strong> <span id="stats-total-games">{{ stats.total_games }}</span></p>
                            <p><strong>Average Incorrect Guesses:</strong> <span id="stats-avg-incorrect">{{ "%.2f"|format(avg_incorrect) }}</span></p>
                        </div>
                        <div class="col-md-6">
                            <p><strong>Current Daily Play Streak:</strong> <span id="stats-current-play-streak">{{ stats.current_play_streak }}</span></p>
                            <p><strong>Longest Daily Play Streak:</strong> <span id="stats-longest-play-streak">{{ stats.longest_play_streak }}</span></p>
                            <p><strong>Current Correct Guess Streak:</strong> <span id="stats-current-correct-streak">{{ stats.current_correct_streak }}</span></p>
                            <p><strong>Longest Correct Guess Streak:</strong> <span id="stats-longest-correct-streak">{{ stats.longest_correct_streak }}</span></p>
                        </div>
                    </div>
                     {% if stats.last_played_datetime %} {# Check if the datetime object exists #}
                     <small class="text-muted" id="stats-last-played">Last game finished: {{ stats.last_played_datetime.strftime('%Y-%m-%d %H:%M:%S') }}</small> {# Format the datetime object #}
                     {% else %}
                     <small class="text-muted" id="stats-last-played"></small>
                     {% endif %}

                     <!-- Add Share Stats Button -->
                     <div class="text-center mt-3">
                         <button id="shareStatsButton" class="btn btn-info btn-sm">Share Overall Stats</button>
                         <span id="copyStatsFeedback" class="ms-2" style="display: none; color: green;">Copied!</span>
                     </div>
                     <!-- End Share Stats Button -->

                </div> {# End stats-body #}
            </div>
            <!-- End Stats Display -->

            <footer class="text-center mt-4 text-muted py-3"> <!-- Added py-3 for padding -->
                &copy; {{ current_year }} Emojile
            </footer>
        </div>

    </div> <!-- End Main Content Wrapper -->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const MAX_GUESSES = {{ max_guesses }};
        let currentEmojiCharacter = ''; // To store the fetched emoji

        // --- ADD THESE VARIABLE DECLARATIONS ---
        const isGameOverOnLoad = {{ is_game_over_on_load|tojson }};
        const dayNumberOnLoad = {{ day_number_on_load|tojson }};
        const incorrectGuessesOnLoad = {{ incorrect_guesses_on_load|tojson }};
        const maxGuessesOnLoad = {{ max_guesses_on_load|tojson }}; // This is same as MAX_GUESSES
        const isWinOnLoad = {{ is_win_on_load|tojson }};
        const nextMidnightISO = {{ next_midnight_iso|tojson }}; // Make sure this is also defined if used before assignment
        // --- END ADDED VARIABLES ---

        document.addEventListener('DOMContentLoaded', () => {
            const darkModeToggle = document.getElementById('darkModeToggle');
            const body = document.body;
            const timerDisplayElement = document.getElementById('timerDisplay');
            const countdownContainer = document.getElementById('countdownTimer');
            const shareSection = document.getElementById('share-section'); // Declare shareSection only once
            const shareButton = document.getElementById('shareButton');
            const copyFeedback = document.getElementById('copy-feedback');
            const shareStatsButton = document.getElementById('shareStatsButton');
            const copyStatsFeedback = document.getElementById('copyStatsFeedback');

            // --- NEW: Set Share Button Data on Load if Game Over ---
            if (isGameOverOnLoad && shareButton) {
                 console.log("Setting share button data on page load."); // Debug log
                 shareButton.dataset.dayNumber = dayNumberOnLoad;
                 // Calculate attempts based on loaded state
                 const attemptsOnLoad = incorrectGuessesOnLoad + (isWinOnLoad ? 1 : 0);
                 shareButton.dataset.attempts = attemptsOnLoad;
                 shareButton.dataset.maxGuesses = maxGuessesOnLoad;
                 shareButton.dataset.isWin = isWinOnLoad;
            }
            // --- END NEW ---

            // --- Countdown Timer Logic ---
            let timerInterval = null;

            function updateCountdown() {
                if (!nextMidnightISO || nextMidnightISO === 'null' || !timerDisplayElement) {
                    if(countdownContainer) countdownContainer.style.display = 'none'; // Hide if no time
                    return; // Exit if no target time or element
                }

                const targetTime = new Date(nextMidnightISO).getTime();
                const now = new Date().getTime();
                const difference = targetTime - now;

                if (difference <= 0) {
                    // Time is up or passed
                    timerDisplayElement.textContent = "Ready!";
                    if(countdownContainer) countdownContainer.innerHTML = "<strong>New Emojile available!</strong> Refresh the page.";
                    clearInterval(timerInterval); // Stop the timer
                } else {
                    // Calculate hours, minutes, seconds
                    const hours = Math.floor((difference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((difference % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((difference % (1000 * 60)) / 1000);

                    // Format H:MM:SS
                    timerDisplayElement.textContent =
                        `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                    if(countdownContainer) countdownContainer.style.display = 'block'; // Ensure visible
                }
            }

            // Initial call and set interval
            if (nextMidnightISO && nextMidnightISO !== 'null') {
                 updateCountdown(); // Run once immediately
                 timerInterval = setInterval(updateCountdown, 1000); // Update every second
            } else {
                 if(countdownContainer) countdownContainer.style.display = 'none'; // Hide if no time initially
            }
            // --- End Countdown Timer Logic ---


            // --- Dark Mode Logic ---
            const applyTheme = (theme) => {
                if (theme === 'dark') {
                    body.classList.add('dark-mode');
                    darkModeToggle.textContent = '‚òÄÔ∏è'; // Sun icon for light mode
                } else {
                    body.classList.remove('dark-mode');
                    darkModeToggle.textContent = 'üåô'; // Moon icon for dark mode
                }
            };

            // Check localStorage for saved theme
            const savedTheme = localStorage.getItem('theme') || 'light'; // Default to light
            applyTheme(savedTheme);

            // Toggle button event listener
            darkModeToggle.addEventListener('click', () => {
                const currentTheme = body.classList.contains('dark-mode') ? 'dark' : 'light';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                localStorage.setItem('theme', newTheme); // Save preference
                applyTheme(newTheme);
            });
            // --- End Dark Mode Logic ---


            // --- NEW Emoji Fetch and Display Logic for Pixelated ---
            const initialRiddleId = {{ current_riddle_id|tojson }};
            const initialIncorrectGuesses = {{ incorrect_guesses|tojson }};
            const initialGameMode = {{ selected_mode|tojson }}; // Should be 'Pixelated'
            const initialIsGameOver = {{ game_over|tojson }};

            if (initialRiddleId) {
                fetchEmojiAndDisplay(initialRiddleId, initialIncorrectGuesses, initialGameMode, initialIsGameOver);
            } else {
                displayEmoji('', 0, initialGameMode, true);
            }
            // --- End NEW Emoji Fetch ---

            // --- Existing Keyboard Listener ---
            document.addEventListener('keydown', (event) => {
                const key = event.key.toLowerCase();
                if (key.length === 1 && key >= 'a' && key <= 'z') {
                    const tile = document.getElementById(`tile-${key}`);
                    if (tile && !tile.classList.contains('disabled')) {
                        // Simulate click or directly navigate
                        window.location.href = tile.href;
                    }
                }
            });
            // --- End Keyboard Listener ---

            // --- NEW: AJAX Guess Handling ---
            const alphabetContainer = document.querySelector('.alphabet-tiles');
            const answerDisplayContainer = document.querySelector('.answer-display');
            const guessesLeftDisplay = document.getElementById('guesses-left-display');
            const statsCard = document.getElementById('stats-card');
            const statsBody = document.getElementById('stats-body');
            const flashContainer = document.querySelector('.container'); // Target container to add flash messages

            // Use event delegation
            if (alphabetContainer) {
                alphabetContainer.addEventListener('click', handleGuess);
            }

            async function handleGuess(event) {
                // Only act on letter tiles that are buttons and not disabled
                if (!event.target.matches('.letter-tile:not(:disabled)')) {
                    return;
                }

                const button = event.target;
                const letter = button.dataset.letter;

                // Disable button immediately for feedback
                button.disabled = true;
                button.classList.add('disabled');

                try {
                    const response = await fetch("{{ url_for('main.make_guess') }}", {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({ guess: letter })
                    });

                    const data = await response.json();

                    if (!response.ok || !data.success) {
                        console.error("Guess Error:", data.error || `HTTP error! status: ${response.status}`);
                        addFlashMessage(data.error || 'An error occurred.', 'danger');
                        if (data.error?.toLowerCase().indexOf('already guessed') === -1 && data.error?.toLowerCase().indexOf('game is already over') === -1) {
                             button.disabled = false;
                             button.classList.remove('disabled');
                        }
                        return;
                    }

                    // --- Success: Update UI ---

                    // 1. Update Answer Display using data.answer_display from server
                    const serverAnswerDisplay = data.answer_display; // Correct: from server response
                    serverAnswerDisplay.split('').forEach((char, index) => {
                        const tile = document.getElementById(`answer-char-${index}`);
                        if (tile) {
                            if (char === ' ') {
                                tile.innerHTML = '&nbsp;'; 
                                tile.classList.add('space');
                                tile.classList.remove('revealed'); 
                            } else if (char === '_') {
                                tile.innerHTML = '&nbsp;'; 
                                tile.classList.remove('space');
                                tile.classList.remove('revealed');
                            } else { 
                                tile.textContent = char.toUpperCase();
                                tile.classList.remove('space');
                                tile.classList.add('revealed'); 
                            }
                        }
                    });

                    // 2. Update Guesses Left
                    if(guessesLeftDisplay) { 
                        guessesLeftDisplay.textContent = `Guesses left: ${ MAX_GUESSES - data.incorrect_guesses }`;
                    }

                    // 3. Style the guessed letter tile
                    if (data.is_correct) {
                        button.classList.add('correct');
                    }

                    // Update Pixelation
                    const currentRiddleIdForPixelation = {{ game_config_data.initialRiddleId | tojson if game_config_data else current_riddle_id | tojson }};
                    const currentGameModeForPixelation = {{ game_config_data.initialGameMode | tojson if game_config_data else selected_mode | tojson }};
                    
                    fetchEmojiAndDisplay(
                        currentRiddleIdForPixelation,
                        data.incorrect_guesses, 
                        currentGameModeForPixelation,
                        data.game_over          
                    );
                    
                    // 4. Handle Game Over
                    if (data.game_over) {
                        if (alphabetContainer) {
                            alphabetContainer.querySelectorAll('.letter-tile:not(.disabled)').forEach(tile => {
                                tile.disabled = true;
                                tile.classList.add('disabled');
                            });
                        }

                        // The main answer display update (Step 1 above) already handles showing the full answer
                        // when data.game_over is true because data.answer_display will be the full answer.

                        const message = data.is_win ? 'Congratulations! You guessed it!' : 'Too many guesses! Better luck next time.';
                        const msgCategory = data.is_win ? 'success' : 'warning';
                        addFlashMessage(message, msgCategory);
                        addFlashMessage(`The answer was: ${serverAnswerDisplay.toUpperCase()}`, 'info'); // Use serverAnswerDisplay

                        if (data.stats) {
                            updateStatsDisplay(data.stats);
                            if (statsCard) statsCard.style.display = 'block';
                        }

                        if (shareSection) {
                            shareSection.style.display = 'block';
                            if(shareButton) { 
                                shareButton.dataset.dayNumber = dayNumberOnLoad; 
                                shareButton.dataset.attempts = data.incorrect_guesses + (data.is_win ? 1 : 0);
                                shareButton.dataset.maxGuesses = MAX_GUESSES; 
                                shareButton.dataset.isWin = data.is_win;
                            }
                        }
                    }

                } catch (error) {
                    console.error('Fetch error:', error);
                    addFlashMessage('A network error occurred. Please try again.', 'danger');
                    button.disabled = false;
                    button.classList.remove('disabled');
                }
            }

            // --- Share Button Logic ---
            if (shareButton) {
                shareButton.addEventListener('click', copyShareText);
            }

            function copyShareText() {
                const dayNumber = shareButton.dataset.dayNumber;
                const attempts = shareButton.dataset.attempts;
                const maxGuesses = shareButton.dataset.maxGuesses;
                const isWin = shareButton.dataset.isWin === 'true'; // Convert string back to boolean

                // Basic text format (can be enhanced later with squares)
                let shareText = `Emojile Day ${dayNumber}\n`;
                if (isWin) {
                    shareText += `Guessed in ${attempts}/${maxGuesses} attempts! üéâ\n`;
                } else {
                    shareText += `X/${maxGuesses} attempts üò•\n`;
                }
                shareText += `\n#emojile ${window.location.href}`; // Add hashtag and link

                // Use Clipboard API
                navigator.clipboard.writeText(shareText).then(() => {
                    // Success feedback
                    if (copyFeedback) {
                        copyFeedback.style.display = 'inline'; // Show "Copied!"
                        shareButton.disabled = true; // Temporarily disable button
                        setTimeout(() => {
                            copyFeedback.style.display = 'none'; // Hide after 2 seconds
                            shareButton.disabled = false; // Re-enable button
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    addFlashMessage('Failed to copy score. Please try again.', 'danger');
                });
            }
            // --- End Share Button Logic ---

            // --- NEW: Share Stats Button Logic ---
            if (shareStatsButton) {
                shareStatsButton.addEventListener('click', copyOverallStats);
            }

            function copyOverallStats() {
                // Read stats directly from the displayed elements
                const totalGames = document.getElementById('stats-total-games')?.textContent || 'N/A';
                const avgIncorrect = document.getElementById('stats-avg-incorrect')?.textContent || 'N/A';
                const currentPlayStreak = document.getElementById('stats-current-play-streak')?.textContent || 'N/A';
                const longestPlayStreak = document.getElementById('stats-longest-play-streak')?.textContent || 'N/A';
                const currentCorrectStreak = document.getElementById('stats-current-correct-streak')?.textContent || 'N/A';
                const longestCorrectStreak = document.getElementById('stats-longest-correct-streak')?.textContent || 'N/A';

                // Construct the text
                let statsText = `My Emojile Stats:\n`;
                statsText += `Total Games: ${totalGames}\n`;
                statsText += `Avg Incorrect Guesses: ${avgIncorrect}\n`;
                statsText += `Current Play Streak: ${currentPlayStreak} üî•\n`;
                statsText += `Longest Play Streak: ${longestPlayStreak}\n`;
                statsText += `Current Correct Streak: ${currentCorrectStreak} ‚úÖ\n`;
                statsText += `Longest Correct Streak: ${longestCorrectStreak}\n`;
                statsText += `\nPlay Emojile! ${window.location.href}`;

                // Use Clipboard API
                navigator.clipboard.writeText(statsText).then(() => {
                    // Success feedback
                    if (copyStatsFeedback) {
                        copyStatsFeedback.style.display = 'inline'; // Show "Copied!"
                        shareStatsButton.disabled = true; // Temporarily disable button
                        setTimeout(() => {
                            copyStatsFeedback.style.display = 'none'; // Hide after 2 seconds
                            shareStatsButton.disabled = false; // Re-enable button
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Failed to copy stats text: ', err);
                    addFlashMessage('Failed to copy stats. Please try again.', 'danger');
                });
            }
            // --- End Share Stats Button Logic ---

            // Helper function to add flash messages dynamically
            function addFlashMessage(message, category) {
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert alert-${category} alert-dismissible fade show`;
                alertDiv.setAttribute('role', 'alert');
                alertDiv.innerHTML = `
                    ${message}
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                `;
                // Insert after the countdown timer or H1
                const referenceNode = document.getElementById('countdownTimer') || document.querySelector('h1');
                if (referenceNode && referenceNode.parentNode) {
                     referenceNode.parentNode.insertBefore(alertDiv, referenceNode.nextSibling);
                } else {
                     flashContainer.insertBefore(alertDiv, flashContainer.firstChild); // Fallback
                }

                 // Auto-dismiss after a few seconds (optional)
                 setTimeout(() => {
                     const bootstrapAlert = bootstrap.Alert.getOrCreateInstance(alertDiv);
                     if (bootstrapAlert) {
                         bootstrapAlert.close();
                     }
                 }, 7000); // 7 seconds
            }

            // Helper function to update stats display
            function updateStatsDisplay(statsData) {
                const fields = {
                    'stats-total-games': statsData.total_games,
                    'stats-avg-incorrect': statsData.avg_incorrect.toFixed(2),
                    'stats-current-play-streak': statsData.current_play_streak,
                    'stats-longest-play-streak': statsData.longest_play_streak,
                    'stats-current-correct-streak': statsData.current_correct_streak,
                    'stats-longest-correct-streak': statsData.longest_correct_streak,
                    'stats-last-played': statsData.last_played_datetime_str ? `Last game finished: ${statsData.last_played_datetime_str}` : ''
                };
                for (const id in fields) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = fields[id];
                    }
                }
            }

            // When a guess is made and you get a response, update the display:
            // Inside your handleGuessResponse function:
            // fetchEmojiAndDisplay(
            //     {{ current_riddle_id|tojson }}, // Assuming riddle ID doesn't change mid-game
            //     data.incorrect_guesses,
            //     {{ selected_mode|tojson }},
            //     data.game_over
            // );
            // ...
        }); // End DOMContentLoaded

        async function fetchEmojiAndDisplay(riddleId, incorrectGuesses, gameMode, isGameOver) {
            if (!riddleId) {
                console.log("No riddle ID, clearing emoji display.");
                displayEmoji('', incorrectGuesses, gameMode, isGameOver); // Clear display
                return;
            }

            // Fetch the emoji if we don't have it or if it's for a new riddle
            // For simplicity, let's assume we always fetch if riddleId is present,
            // or you can cache `currentEmojiCharacter` if `riddleId` matches session's.
            try {
                const response = await fetch(`/api/get-emoji/${riddleId}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch emoji: ${response.statusText}`);
                }
                const data = await response.json();
                if (data.emoji) {
                    currentEmojiCharacter = data.emoji;
                    displayEmoji(currentEmojiCharacter, incorrectGuesses, gameMode, isGameOver);
                } else {
                    console.error("Emoji not found in API response for riddle ID:", riddleId);
                    displayEmoji('', incorrectGuesses, gameMode, isGameOver); // Clear display
                }
            } catch (error) {
                console.error("Error fetching emoji:", error);
                displayEmoji('', incorrectGuesses, gameMode, isGameOver); // Clear display on error
            }
        }

        function displayEmoji(emojiChar, incorrectGuesses, gameMode, isGameOver) {
            const canvas = document.getElementById('pixelated-emoji-canvas');
            const emojiContainer = document.getElementById('emoji-container');

            if (!canvas || !emojiContainer) {
                console.error("Required emoji display elements (canvas or container) not found for Pixelated mode!");
                return;
            }

            const displayChar = emojiChar || '‚ùì'; 

            canvas.style.display = 'block'; 
            emojiContainer.classList.add('pixelated-mode');
            emojiContainer.classList.remove('classic-mode');

            const ctx = canvas.getContext('2d');
            const canvasSize = 128; 
            canvas.width = canvasSize;
            canvas.height = canvasSize;

            let virtualResolution = 8; 
            if (isGameOver || incorrectGuesses >= MAX_GUESSES) {
                virtualResolution = canvasSize; 
            } else if (incorrectGuesses === 1) {
                virtualResolution = 16;
            } else if (incorrectGuesses === 2) {
                virtualResolution = 32;
            }
            // ... (add more steps if MAX_GUESSES is higher) ...


            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d');
            const sourceSize = 256; 
            offscreenCanvas.width = sourceSize;
            offscreenCanvas.height = sourceSize;

            offscreenCtx.clearRect(0, 0, sourceSize, sourceSize);
            // --- CHANGE 1: Increase relative font size ---
            offscreenCtx.font = `${sourceSize * 0.82}px Arial`; // Was 0.75, try 0.82 for a slightly larger emoji
            offscreenCtx.textAlign = 'center';
            offscreenCtx.textBaseline = 'middle'; 
            // --- CHANGE 2: Adjust Y-position for better centering with 'middle' baseline ---
            offscreenCtx.fillText(displayChar, sourceSize / 2, sourceSize / 2); // Was sourceSize / 2 + (sourceSize * 0.05)

            const tempSmallCanvas = document.createElement('canvas');
            tempSmallCanvas.width = virtualResolution;
            tempSmallCanvas.height = virtualResolution;
            const tempSmallCtx = tempSmallCanvas.getContext('2d');

            tempSmallCtx.imageSmoothingEnabled = false;
            tempSmallCtx.drawImage(offscreenCanvas, 0, 0, sourceSize, sourceSize, 0, 0, virtualResolution, virtualResolution);

            ctx.clearRect(0, 0, canvasSize, canvasSize);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempSmallCanvas, 0, 0, virtualResolution, virtualResolution, 0, 0, canvasSize, canvasSize);
        }

        // Modify your handleGuessResponse function (or equivalent)
        function handleGuessResponse(data) {
            // ... (update guesses, results, keyboard, etc.) ...
            updateIncorrectGuessesDisplay(data.incorrect_guesses); // You'll need this function

            // Update emoji display based on new state
            const currentRiddleId = {{ current_riddle_id|tojson }}; // Get current riddle ID
            const currentGameMode = {{ selected_mode|tojson }};   // Get current game mode

            fetchEmojiAndDisplay(currentRiddleId, data.incorrect_guesses, currentGameMode, data.game_over);

            if (data.game_over) {
                // ... (handle game over, show modal, etc.) ...
            }
            // ...
        }
        // You'll also need a function to update the display of incorrect guess count if you have one
        function updateIncorrectGuessesDisplay(count) {
            const displayElement = document.getElementById('incorrect-guesses-count'); // Example ID
            if (displayElement) {
                displayElement.textContent = `${count} / ${MAX_GUESSES}`;
            }
        }
    </script>
</body>
</html>